### 1. 가르침(1062)
- 26개 알파벳에서 k개의 글자만 사용할 수 있을 때, 어떤 k개를 알아야 단어를 최대한 많이
읽을 수 있을까?
- "antic"은 무조건 알고 있어야 한다 -> antic을 제외한 k-5개를 구한다.
- k-5개 모든 조합마다 몇개의 단어를 읽을 수 있는지 확인해서 최대값을 구한다
- 완전 탐색 -> 시간 복잡도: 21C(k-5)의 최대값=(21C10) * (n=50) * (글자길이=15) = 이백만 정도
- antic을 포함 안시키면 연산횟수가 26C13 -> 으로 커져서 백억 단위로 나옴
- 의미: (모든 조합) * (모든 단어) * (조합이 단어의 모든 글자를 포함하는가)

<br>

### 2. 이분 그래프(1707)
이분 그래프란? - 인접한 노드끼리는 항상 다른 집합이면서, 모든 노드를 두 집합으로 나눌 수 있는 그래프 <br><br>
**방법)** 
   1) DFS나 BFS를 사용해서 현재노드와 인접노드를 다른 색으로 칠해준다.
   2) 그래프의 모든 노드를 확인해서 인접노드와 같은 색으로 칠해진 노드가 있는지 확인한다.
※ 연결그래프라면 DFS/BFS를 사용해서 더 빠르게 확인할 수 있다.


<br>

### 3. 알파벳(1987)
- 갈 수 있는 모든 경로를 확인해서 최대 이동 횟수를 구한다.
- DFS를 사용해서 모든 방향으로 이동할 수 있는 최대 깊이로 갔다 오면서 정답을 갱신한다.
- 중복 방문은 최대깊이로 이동중일 때만 체크하고, 되돌아오면 체크했던 방문을 해제해줘야 한다. -->
하나의 노드에 같은 알파벳이 인접해있더라도, 방향에 따라 나올 수 있는 경우의 수가 달라지기 때문에
모두 방문해야 한다.

    **내가 실수했던 포인트)**
DFS에서 반복문으로 인접 노드에 재귀함수를 호출하고, 돌아올 때마다 정답을 갱신하도록 구현했다.
이동 횟수를 인자로 넘겨줄 때, 갱신된 정답을 넘겨서 이동횟수가 이상하게 증가가 됐다. 
현재 노드까지의 이동횟수+1을 넘기도록 수정해서 정상 작동하는 것을 확인할 수 있었다.

<br>

### 4. 수 묶기(1744) <br>
- 수열의 합의 최대값을 구하라, 위치 상관없이 2개의 수를 곱해서 더하거나, 하나씩 낱개로 더할 수 있다. <br> 수의 범위: -10,000 ~ 10,000 
- 보통 곱할수록 커지니까 곱해서 더 크게 만드는 방법을 생각하자. <br><br>
#### **greedy)**
    - 큰 수를 곱할수록 더 커진다. -> 정렬해서 greedy하게 차례대로 큰 것끼리 묶는다.
    - 음수) 음수x음수 = 양수 -> 정렬해서 작은것부터 차례대로 묶는다.
    - 2개씩 묶으면 하나가 남을 수도 있다 -> 정렬을 하므로 절대값이 가장 작은게 남게된다.
      - 음수 -> 0과 곱하면 더 커진다. 0이 없으면 내비둔다.
      - 양수 -> 낱개로 더한다.
    
    - 곱하기 -> **1을 생각해야 한다** -> 1은 무언가를 곱하는 것보다 더할수록 커진다 -> 1은 모두 낱개로 더하고, 나머지
    양수에 대해 양수 처리법을 적용한다.

**리뷰)**
처음에 greedy 알고리즘임을 눈치채지 못했다. 풀이법을 떠올리지 못했다.
계속 틀려서 찾아보니 1을 따로 빼줘야 했다. **곱하기는 음수, 0, 1이 특별하다.**

<br>

### 5. 카드 정렬하기(1715)
- 수열에서 값을 2개씩 꺼내서 합을 구하고 정답에 누적시킨다. 합한 값은 수열에 넣는다. 그렇게 수열에 수가 하나가 남을 때까지 반복해서 얻을 수 있는 전체 합의 최대 값을 구하는 문제다.
- 합한 값은 계속 다시 사용되기 때문에 매번 합이 최소가 되는 두 수를 더해야 한다.
즉, 매번 가장 작은 2개의 값을 더하는 **greedy** 풀이법을 사용해야 한다.

- 정렬된 수열에 합한 값을 넣을 때마다 재정렬을 하면 n의 시간이 필요하므로, 전체 O(n^2)의 시간이 필요해서 시간 내에 해결할 수 없다. 
**우선순위 큐**를 사용하면 (logn)번만에 재정렬이 가능하니까 시간제한 안에 해결할 수 있다.

<br>

### 6. 세 용액(2473)
1) 오름차순 정렬
2) 값 하나는 반복문으로 설정
3) 나머지 두 값을 투포인터를 사용해서 양 끝에서 모든 수를 확인하면서 0에 가까운 합을 찾는다.
4) 투 포인터를 움직일 때마다 해당 반복에 대한 답을 갱신한다.
5) 반복문이 끝나면 지금까지의 정답과 비교해서 정답을 갱신한다.   

<br>

### 7. 최단경로(1753)
다익스트라 사용, 우선순위 큐를 이용해서 O(nlogn)으로 시간복잡도 단축

<br>

### 8. 특정한 최단 경로(1504)
1) 다익스트라 3번 사용
2) (start -> v1 -> v2 ->(end), (start) -> v2 -> v1 -> end)의 최소값을 구한다.
3) 값이 INF보다 크거나 같으면 -1, 아니면 최소 값 출력

4) **1번 수정 - 다익스트라를 v1, v2에 대해서만 돌려도 start <-> v1 or v2를 알 수 있으므로, 다익스트라를 2번만 사용하면 된다.**